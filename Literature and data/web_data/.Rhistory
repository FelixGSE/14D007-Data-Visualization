sQuote("s2")
dQuote("s2")
dQuote(s2)
dQuote('a')
sQuote('a')
options(useFancyQuotes = FALSE)
cat("\ndistinguish plain", sQuote("single"), "and",
dQuote("double"), "quotes\n")
options(useFancyQuotes = TRUE)
cat("\ndistinguish plain", sQuote("single"), "and",
dQuote("double"), "quotes\n")
options( useFancyQuotes = FALSE )
# Compute and format nodes
for( i in 1:M ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),'},'),
paste0('{ name:',sQuote(sector[i,1]),'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
node.list
# Compute and format nodes
for( i in 1:M ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),'ind',in.temp[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),,'ind',in.temp[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
for( i in 1:M ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),'ind',in.temp[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),'ind',in.temp[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
node.list
M <- nrow(sector)
node.list <- c()
in.centrality <- log(as.numeric(colSums(adjacency.matrix)))
in.temp       <- ifelse(in.centrality==-Inf,0,in.centrality)
# Compute and format nodes
for( i in 1:M ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),'ind:',in.temp[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),'ind:',in.temp[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
node.list
M <- nrow(sector)
node.list <- c()
in.centrality <- log(as.numeric(colSums(adjacency.matrix)))
in.temp       <- ifelse(in.centrality==-Inf,0,in.centrality)
# Compute and format nodes
for( i in 1:M ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
node.list
# Design final output
open   <- "var dataset = {nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
# Save data to HD
write(graph,'graph_data.js')
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Initialize node list and iteration
M <- nrow(sector)
node.list <- c()
in.centrality <- log(as.numeric(colSums(adjacency.matrix)))
in.temp       <- ifelse(in.centrality==-Inf,0,in.centrality)
# Compute and format nodes
for( i in 1:M ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
# Design final output
open   <- "var dataset = {nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
# Save data to HD
graph
head(graph)
write(graph,'graph_data.js')
### Clear workspace
rm(list = ls())
### Load data
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Analysis/')
iot    <- read.csv( 'iot_clean.csv', sep = ';', header = FALSE )
sector <- read.csv( 'product_groups.csv', sep = ';', header = FALSE )
### Load Packages
### Set options
options( useFancyQuotes = FALSE )
### Initialize auxilliary functions
source('centrality_functions.R')
### Reset working directory for output
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/App/data/')
################################################################################
# Covert adjacency matrix to d3 format
################################################################################
# Compute binary adjacency matrix
adjacency.matrix <- ifelse(iot>0,1,0)
# Initialize empty edge list
N         <- nrow(adjacency.matrix)
edge.list <- c(NA)
# Compute edge list for java script
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Initialize node list and iteration
M <- nrow(sector)
node.list <- c()
in.centrality <- log(as.numeric(colSums(adjacency.matrix)))
in.temp       <- ifelse(in.centrality==-Inf,0,in.centrality)
# Compute and format nodes
for( i in 1:M ){
node.list[i] <- ifelse( i < M,
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],'},'),
paste0('{ name:',sQuote(sector[i,1]),',ind:',in.temp[i],'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
# Design final output
open   <- "var dataset = { nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
# Save data to HD
write(graph,'graph_data.js')
demand <- read.csv( 'final_demand.csv', sep = ';', header = FALSE )
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Analysis/')
demand <- read.csv( 'final_demand.csv', sep = ';', header = FALSE )
demand
demand <- read.csv( 'final_demand.csv', sep = ';', header = FALSE,
col.names = paste0("V",2:66) )
### Clear workspace
rm(list = ls())
### Load data
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Literature and data/Raw_data/')
iot          <- read.csv( 'iot_clean.csv', sep = ';', header = FALSE )
sector       <- read.csv( 'product_groups_clean.csv', sep = ';', header = FALSE )
value.added  <- read.csv( 'value_added_clean.csv', sep = ';', header = FALSE )
employment   <- read.csv( 'labour_input_clean.csv',sep = ';',header=FALSE )
final.demand <- read.csv( 'final_demand_clean.csv',sep = ';',header=FALSE )
### Load Packages
### Set options
options( useFancyQuotes = FALSE )
### Initialize auxilliary functions
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Analysis/')
source('centrality_functions.R')
################################################################################
# Compute centrality meassures for IO-Graph
################################################################################
# Convert data frame to class matrix and delete column names
N   <- nrow( iot )
# Compute binary adjacency matrix and both in and outlist
adjacency.matrix <- ifelse( iot > 0 , 1 , 0 )
in.list          <- colSums(adjacency.matrix)
out.list         <- rowSums(adjacency.matrix)
# Find unconnected and absorbing nodes
zero      <- which( out.list == 0 & in.list == 0 )
absorbing <- which( out.list  < 2 & in.list  > 0 )
drops     <- c( zero, absorbing )
# Clean IOT - Drop found sectors
all.sectors <- 1:N
keeps       <- setdiff( all.sectors , drops )
iot.clean   <- as.matrix( iot[ keeps , keeps ] )
# Compute centrality meassures
rwclose <- random.walk.closeness.centrality(iot.clean)
rwcount <- random.walk.counting.centrality(iot.clean)
# Adjust output - Assign zero for
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( i < ( N + 1)  ) {
bool <- i == drop.counter
if( any( bool ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
i <- i+1
}
################################################################################
# Covert data to d3 format
################################################################################
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < N,
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000 ,',cou:',rw.counting[i],
',em:',employment[1,i],',va:',value.added[1,i] ,',fd:', final.demand[1,i] , '},'),
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000,',cou:',rw.counting[i],
',em:',employment[1,i],',va:',value.added[1,i] ,',fd:', final.demand[1,i] ,'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
# Initialize empty edge list
edge.list <- c(NA)
# Compute edge list for java script
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Design final output
open   <- "var dataset = { nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
################################################################################
################################################################################
# Reset working directory for output
setwd( '/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/App/data/' )
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Literature and data/Raw_data/')
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Literature and data')
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Analysis/')
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Analysis/')
source('centrality_functions.R')
setwd( '/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Literature and data/web_data/' )
################################################################################
### Clear workspace
rm(list = ls())
### Load data
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Literature and data')
iot          <- read.csv( 'iot_clean.csv', sep = ';', header = FALSE )
sector       <- read.csv( 'product_groups_clean.csv', sep = ';', header = FALSE )
value.added  <- read.csv( 'value_added_clean.csv', sep = ';', header = FALSE )
employment   <- read.csv( 'labour_input_clean.csv',sep = ';',header=FALSE )
final.demand <- read.csv( 'final_demand_clean.csv',sep = ';',header=FALSE )
### Load Packages
### Set options
options( useFancyQuotes = FALSE )
### Initialize auxilliary functions
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Analysis/')
source('centrality_functions.R')
################################################################################
# Compute centrality meassures for IO-Graph
################################################################################
# Convert data frame to class matrix and delete column names
N   <- nrow( iot )
# Compute binary adjacency matrix and both in and outlist
adjacency.matrix <- ifelse( iot > 0 , 1 , 0 )
in.list          <- colSums(adjacency.matrix)
out.list         <- rowSums(adjacency.matrix)
# Find unconnected and absorbing nodes
zero      <- which( out.list == 0 & in.list == 0 )
absorbing <- which( out.list  < 2 & in.list  > 0 )
drops     <- c( zero, absorbing )
# Clean IOT - Drop found sectors
all.sectors <- 1:N
keeps       <- setdiff( all.sectors , drops )
iot.clean   <- as.matrix( iot[ keeps , keeps ] )
# Compute centrality meassures
rwclose <- random.walk.closeness.centrality(iot.clean)
rwcount <- random.walk.counting.centrality(iot.clean)
# Adjust output - Assign zero for
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( i < ( N + 1)  ) {
bool <- i == drop.counter
if( any( bool ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
i <- i+1
}
################################################################################
# Covert data to d3 format
################################################################################
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < N,
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000 ,',cou:',rw.counting[i],
',em:',employment[1,i],',va:',value.added[1,i] ,',fd:', final.demand[1,i] , '},'),
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000,',cou:',rw.counting[i],
',em:',employment[1,i],',va:',value.added[1,i] ,',fd:', final.demand[1,i] ,'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
# Initialize empty edge list
edge.list <- c(NA)
# Compute edge list for java script
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Design final output
open   <- "var dataset = { nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
################################################################################
################################################################################
# Reset working directory for output
setwd( '/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Literature and data/web_data/' )
# S
### Clear workspace
rm(list = ls())
### Load data
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Literature and data')
iot          <- read.csv( 'iot_clean.csv', sep = ';', header = FALSE )
sector       <- read.csv( 'product_groups_clean.csv', sep = ';', header = FALSE )
value.added  <- read.csv( 'value_added_clean.csv', sep = ';', header = FALSE )
employment   <- read.csv( 'labour_input_clean.csv',sep = ';',header=FALSE )
final.demand <- read.csv( 'final_demand_clean.csv',sep = ';',header=FALSE )
### L
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Literature and data/raw_data/')
iot          <- read.csv( 'iot_clean.csv', sep = ';', header = FALSE )
sector       <- read.csv( 'product_groups_clean.csv', sep = ';', header = FALSE )
value.added  <- read.csv( 'value_added_clean.csv', sep = ';', header = FALSE )
employment   <- read.csv( 'labour_input_clean.csv',sep = ';',header=FALSE )
final.demand <- read.csv( 'final_demand_clean.csv',sep = ';',header=FALSE )
### Load Packages
### Set options
options( useFancyQuotes = FALSE )
### Initialize auxilliary functions
setwd('/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Analysis/')
source('centrality_functions.R')
################################################################################
# Compute centrality meassures for IO-Graph
################################################################################
# Convert data frame to class matrix and delete column names
N   <- nrow( iot )
# Compute binary adjacency matrix and both in and outlist
adjacency.matrix <- ifelse( iot > 0 , 1 , 0 )
in.list          <- colSums(adjacency.matrix)
out.list         <- rowSums(adjacency.matrix)
# Find unconnected and absorbing nodes
zero      <- which( out.list == 0 & in.list == 0 )
absorbing <- which( out.list  < 2 & in.list  > 0 )
drops     <- c( zero, absorbing )
# Clean IOT - Drop found sectors
all.sectors <- 1:N
keeps       <- setdiff( all.sectors , drops )
iot.clean   <- as.matrix( iot[ keeps , keeps ] )
# Compute centrality meassures
rwclose <- random.walk.closeness.centrality(iot.clean)
rwcount <- random.walk.counting.centrality(iot.clean)
# Adjust output - Assign zero for
rw.closeness <- c( )
rw.counting  <- c( )
drop.counter <- drops
i <- 1
j <- 1
while ( i < ( N + 1)  ) {
bool <- i == drop.counter
if( any( bool ) ){
pos <- which( bool == i )
drop.counter <- setdiff( drop.counter, drop.counter[pos] )
rw.closeness[i] <- 0
rw.counting[i]  <- 0
} else {
rw.closeness[i] <- rwclose[j]
rw.counting[i]  <- rwcount[j]
j <- j + 1
}
i <- i+1
}
################################################################################
# Covert data to d3 format
################################################################################
# Initialize empty node list
node.list <- c( )
# Compute and format nodes
for( i in 1:N ){
node.list[i] <- ifelse( i < N,
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000 ,',cou:',rw.counting[i],
',em:',employment[1,i],',va:',value.added[1,i] ,',fd:', final.demand[1,i] , '},'),
paste0('{ name:',sQuote(sector[i,1]),',nor:',10,
',clo:',rw.closeness[i] * 1000,',cou:',rw.counting[i],
',em:',employment[1,i],',va:',value.added[1,i] ,',fd:', final.demand[1,i] ,'}')
)
}
# Remove quotes
node.list <- noquote(node.list)
# Initialize empty edge list
edge.list <- c(NA)
# Compute edge list for java script
for( i in 1:N){
# Compute out list for node i
temp.out.list <- adjacency.matrix[i,]
# Loop over adjacent nodes j of node i
for( j in 1:N ){
# If there is an edge append to list
if(  temp.out.list[j] != 0 ){
edge <- paste0('{ source:',(i-1),', target:',(j-1),'},')
current.index <- length(edge.list) + 1
edge.list[current.index] <- edge
}
}
# Last iteration add no comma
if( i == N ){
last.index <- current.index - 1
edge.list[last.index] <- paste0('{ source:',(i-1),', target:',(j-1),'}')
edge.list <- edge.list[2:last.index]
}
}
# Design final output
open   <- "var dataset = { nodes: ["
bridge <-  "],edges: ["
close  <- "]};"
graph  <- noquote( c( open , node.list , bridge , edge.list , close ) )
################################################################################
################################################################################
# Reset working directory for output
setwd( '/Users/felix/Documents/GSE/Term 2/14D007 Data Visualization/Project/Data-Visualisation-2015/Literature and data/web_data/' )
